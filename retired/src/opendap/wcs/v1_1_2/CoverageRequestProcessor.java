/*
 * /////////////////////////////////////////////////////////////////////////////
 * // This file is part of the "Hyrax Data Server" project.
 * //
 * //
 * // Copyright (c) 2013 OPeNDAP, Inc.
 * // Author: Nathan David Potter  <ndp@opendap.org>
 * //
 * // This library is free software; you can redistribute it and/or
 * // modify it under the terms of the GNU Lesser General Public
 * // License as published by the Free Software Foundation; either
 * // version 2.1 of the License, or (at your option) any later version.
 * //
 * // This library is distributed in the hope that it will be useful,
 * // but WITHOUT ANY WARRANTY; without even the implied warranty of
 * // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * // Lesser General Public License for more details.
 * //
 * // You should have received a copy of the GNU Lesser General Public
 * // License along with this library; if not, write to the Free Software
 * // Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301
 * //
 * // You can contact OPeNDAP, Inc. at PO Box 112, Saunderstown, RI. 02874-0112.
 * /////////////////////////////////////////////////////////////////////////////
 */
package opendap.wcs.v1_1_2;


import opendap.coreServlet.Scrub;
import opendap.wcs.v1_1_2.http.MultipartResponse;
import opendap.wcs.v1_1_2.http.SoapHandler;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.servlet.http.HttpServletResponse;
import java.util.Iterator;
import java.util.Vector;

/**
 * Process GetCoverage requests. Static methods are used to construct a wcs:Coverages
 * response.
 *
 */
public class CoverageRequestProcessor {


    public static final String COVERAGES_CONTENT_ID = "urn:ogc:wcs:1.1:coverages";




    /**
     * This method is the primary entry point for handling a wcs:GetCoverage request.
     *
     *
     * @param req The GetCoverageRequest object built fromt the client request.
     * @return The wcs:Coverages document generated by the request
     * @throws WcsException When a wcs:Coverages response document cannot be
     * constructed for the passed request.
     */
    public static Document getStoredCoverageResponse(GetCoverageRequest req) throws WcsException, InterruptedException {

        String id = req.getCoverageID();
        boolean b = CatalogWrapper.hasCoverage(id);

        if(!b)
            throw new WcsException("No such wcs:Coverage: "+ Scrub.fileName(id),
                    WcsException.INVALID_PARAMETER_VALUE,"wcs:Identifier");

        String dataAccessURL = getNetcdfDataAccessURL(req);
        String metadataAccessURL = getMetadataAccessURL(req);


        Coverage cvg = new Coverage(id,dataAccessURL, metadataAccessURL);


        Element coverage = cvg.getCoverageElement();

        Element coverages = new Element("Coverages",WCS.WCS_NS);

        coverages.addContent(coverage);

        Iterator i = coverage.getAdditionalNamespaces().iterator();
        while(i.hasNext())
            coverages.addNamespaceDeclaration((Namespace) i.next());

        Document doc = new Document(coverages);


        return doc;





    }


    /**
     * This method is the primary entry point for handling a wcs:GetCoverage request.
     *
     *
     * @param req The GetCoverageRequest object built fromt the client request.
     * @return The wcs:Coverages document generated by the request
     * @throws WcsException When a wcs:Coverages response document cannot be
     * constructed for the passed request.
     */
    public static void sendCoverageResponse(GetCoverageRequest req, HttpServletResponse response, boolean useSoapEnvelope) throws WcsException, InterruptedException {

        String id = req.getCoverageID();
        boolean b = CatalogWrapper.hasCoverage(id);

        if(!b)
            throw new WcsException("No such wcs:Coverage: "+ Scrub.fileName(id),
                    WcsException.INVALID_PARAMETER_VALUE,"wcs:Identifier");


        String format = req.getFormat();


        String dataAccessURL;
        String mime_type;

        if(format.contains("netcdf")){
            dataAccessURL = getNetcdfDataAccessURL(req);
            mime_type = "application/x-netcdf-cf";
        }
        else if (format.contains("dap")){
            dataAccessURL = getDapDataAccessURL(req);
            mime_type = "application/octet-stream";
        }
        else {
            throw new WcsException("Unrecognized response format: "+ Scrub.fileName(format),
                    WcsException.INVALID_PARAMETER_VALUE,"wcs:Ouput/@format");
        }

        String metadataAccessURL = getMetadataAccessURL(req);

        Logger log = LoggerFactory.getLogger(CoverageRequestProcessor.class);

        log.debug("Building multi-part Response...");

        MultipartResponse mpr = new MultipartResponse();


        String dataPartID =  "cid:"+ req.getCoverageID()+".nc";


        Coverage cvg = new Coverage(id,dataPartID, metadataAccessURL);


        Element coverage = cvg.getCoverageElement();

        Element coverages = new Element("Coverages",WCS.WCS_NS);

        coverages.addContent(coverage);

        Iterator i = coverage.getAdditionalNamespaces().iterator();
        while(i.hasNext())
            coverages.addNamespaceDeclaration((Namespace) i.next());

        Document doc = new Document(coverages);


        if(useSoapEnvelope)
            doc = SoapHandler.wrapDocumentInSoapEnvelope(doc);


        mpr.addAttachment("text/xml; charset=UTF-8", COVERAGES_CONTENT_ID,doc);
        mpr.addAttachment(mime_type,dataPartID, dataAccessURL);



        try {
            mpr.send(response);
        } catch (Exception e) {
            throw new WcsException("Failed to transmit WCS coverage response.", WcsException.NO_APPLICABLE_CODE);
        }


    }






    public static String getDapDataAccessURL(GetCoverageRequest req)  throws InterruptedException, WcsException {

        String requestURL = CatalogWrapper.getDataAccessUrl(req.getCoverageID());

        requestURL += req.getCoverageID() + ".dods"+"?"+getDapProjection(req);

        return requestURL;
    }



    public static String getNetcdfDataAccessURL(GetCoverageRequest req)  throws InterruptedException, WcsException {

        String requestURL = CatalogWrapper.getDataAccessUrl(req.getCoverageID());;
        
        requestURL +=  ".nc"+"?"+getDapProjection(req);

        return requestURL;
    }



    public static String getMetadataAccessURL(GetCoverageRequest req)  throws InterruptedException, WcsException {

        String requestURL = CatalogWrapper.getDataAccessUrl(req.getCoverageID());

        requestURL +=   ".ddx";
        //requestURL +=  "/" + req.getCoverageID() + ".ddx"+"?"+getDapProjection(req);

        return requestURL;
    }


    private static String getDapProjection(GetCoverageRequest req) throws InterruptedException, WcsException {

        String proj = null;

        RangeSubset rs = req.getRangeSubset();
        TemporalSubset ts = req.getTemporalSubset();
        String coverageID = req.getCoverageID();
        String fieldID;
        BoundingBox subsetBB = req.getBbox();
        GridCRS reqCRS = req.getGridCRS();

        CoverageDescription coverage = CatalogWrapper.getCoverageDescription(coverageID);
        BoundingBox coverageBB = coverage.getBoundingBox();
        //GridCRS coverageCRS = coverage.getGridCRS();


        if (!subsetBB.intersects(coverageBB))
            throw new WcsException("Requested BoundingBox does not intersect Coverage data.",
                    WcsException.INVALID_PARAMETER_VALUE, "ows:BoundingBox");


        //@todo work out how to deal with GridCRS objects.
        //@todo compare request GridCRS (if there is one) to target coverage GridCRS.
        // @todo Do transformation if required

        if (reqCRS != null) {
            throw new WcsException("Request contains a GridCRS. Since this " +
                    "server does not currently support coordinate transforms the" +
                    "request is denied. You may request the coverage data in " +
                    "its native CRS by simply omitting a GridCRS component from" +
                    "the request. See 'OGC 07-067r5' Table 24 footnote d.",
                    WcsException.INVALID_PARAMETER_VALUE, "wcs:GridCRS");
        }

        FieldSubset[] fields = null;
        if (rs != null)
            fields = req.getRangeSubset().getFieldSubsets();

        if (fields==null || fields.length == 0) {
            Element fieldSubset;
            Element identifier;
            Vector<FieldSubset> allFieldSubsets = new Vector<FieldSubset>();
            for (String id : coverage.getFieldIDs()) {
                fieldSubset = new Element("FieldSubset", WCS.WCS_NS);
                identifier = new Element("Identifier", WCS.OWS_NS);
                fieldSubset.addContent(identifier);
                identifier.setText(id);
                allFieldSubsets.add(new FieldSubset(fieldSubset));

            }
            fields = new FieldSubset[allFieldSubsets.size()];
            fields = allFieldSubsets.toArray(fields);
        }


        for (FieldSubset fs : fields) {

            fieldID = fs.getID();
            if (!CatalogWrapper.getCoverageDescription(coverageID).hasField(fieldID))
                throw new WcsException("No such wcs:Field: " + Scrub.fileName(fieldID),
                        WcsException.INVALID_PARAMETER_VALUE, "ows:Identifier");


            String dapGridId = coverage.getDapGridArrayId(fieldID);
            String dapLatitude = coverage.getLatitudeCoordinateDapId(fieldID);
            String dapLongitude = coverage.getLongitudeCoordinateDapId(fieldID);
            String latLonBoundingBox = subsetBB.getDapGeogridFunctionBoundingBox();


            String dapElevation = coverage.getElevationCoordinateDapId(fieldID);
            String geogridElevationSubset = null;
            if (subsetBB.hasElevation())
                geogridElevationSubset = subsetBB.getDapGeogridFunctionElevationSubset(dapElevation);


            String dapTime = coverage.getTimeCoordinateDapId(fieldID);
            String dapTimeUnits = coverage.getTimeUnits(fieldID);
            String geogridTimeSubset = null;
            if (ts != null)
                geogridTimeSubset = ts.getDapGeogridFunctionTimeSubset(dapTime, dapTimeUnits);


            if (proj != null)
                proj += ",";
            if (proj == null)
                proj = "";


            // Full query.
            proj += "geogrid(" +
                    dapGridId + "," +
                    dapLatitude + "," +
                    dapLongitude + "," +
                    latLonBoundingBox +
                    (geogridElevationSubset != null ? "," + geogridElevationSubset : "") +
                    (geogridTimeSubset != null ? "," + geogridTimeSubset : "") +
                    ")";


            // Does not subset by time or elevation.
            // proj += "geogrid("+fieldID+","+dapLatitude+","+dapLongitude+","+latLonBoundingBox +",\")";


            //proj += "geogrid("+fieldID+","+subsetBB.getDapGeogridFunctionBoundingBox() +")";

            //String gridConstraint = geoIndex(dataAccessUrl,fieldID, subsetBB.getDapGeogridFunctionBoundingBox());

            //proj += fieldID + gridConstraint;


        }
        return proj == null ? "" : proj;
    }


}
